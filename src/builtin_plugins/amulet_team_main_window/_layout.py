"""A module to manage everything about layouts.
Registering layouts, adding layout buttons and enabling layouts"""

from __future__ import annotations
from typing import Callable, cast
from threading import Lock, current_thread, main_thread
from dataclasses import dataclass
import re
from weakref import WeakValueDictionary, ref

from PySide6.QtCore import Qt, QPoint, QSize

from amulet_editor.models.widgets import ATooltipIconButton

from ._main_window import get_main_window
from ._sub_window import sub_windows
from ._tab_engine import TabWidget
from ._toolbar import ButtonProxy


UniqueIdPattern = re.compile(r'[a-z0-9-]+')


# TODO: what should this be?
#  This needs to be picklable
#  The contained data must not depend on the plugin because it may not be active when it is unpickled.
#  It must contain enough info to reconstruct the layout and contained widgets
#  Layout can be a custom object containing division weightings, orientation and contained widgets.
#  Widgets can be the qualified name to the widget and some metadata to reconstruct them.
#   Should widgets have a method to dump the metadata and a class method to reconstruct them with the metadata?
#   If the plugin does not get enabled, the widget will be a missing widget.


@dataclass(frozen=True)
class SplitterConfig:
    first: SplitterConfig | WidgetConfig
    second: SplitterConfig | WidgetConfig
    orientation: Qt.Orientation
    weight: float


@dataclass(frozen=True)
class WidgetConfig:
    qualname: str


@dataclass(frozen=True)
class WindowConfig:
    origin: QPoint | None
    size: QSize | None
    layout: SplitterConfig | WidgetConfig


@dataclass(frozen=True)
class LayoutConfig:
    main_window: WindowConfig
    sub_windows: tuple[WindowConfig, ...]


@dataclass
class LayoutContainer:
    default: LayoutConfig
    layout: LayoutConfig
    button: Callable[[], ATooltipIconButton | None] = cast(Callable[[], ATooltipIconButton | None], lambda: None)


# The lock must be acquired before reading/writing the objects below.
lock = Lock()
# The layouts that have been registered
layouts = dict[str, LayoutContainer]()
# The id for the currently active layout
_active_layout: str | None = None
# Widgets where the class does not exist yet.
_missing_widgets = WeakValueDictionary[str, TabWidget]()


def _get_layout_container(layout_id: str) -> LayoutContainer:
    """Get the layout container for the given layout id.

    The lock must be acquired before calling this.

    :param layout_id: The layout id to get.
    :raises ValueError: If the layout has not been registered.
    :return:
    """
    layout_container = layouts.get(layout_id, None)
    if layout_container is None:
        raise ValueError(f"No registered layout for id {layout_id}")
    return layout_container


def register_layout(layout_id: str, layout: LayoutConfig) -> None:
    """Register a new layout.

    This must be called before a layout can be activated.

    :param layout_id: The unique identifier for the layout.
        The unique id must only contain lower case a-z, 0-9 and - characters.
        We suggest using a UUID generated by https://www.uuidgenerator.net/
        This won't be shown to the user by can be used by other plugins to enable the layout.
    :param layout: The default layout to use.
        If the user has made changes to the layout, the changes will be displayed.
    """
    if UniqueIdPattern.fullmatch(layout_id) is None:
        raise ValueError("")
    with lock:
        if layout_id in layouts:
            raise ValueError(f"Layout id {layout_id} has already been registered.")
        layout_container = LayoutContainer(layout, layout)
        layouts[layout_id] = layout_container


def unregister_layout(layout_id: str) -> None:
    """Unregister the layout.

    When the plugin is unloaded, it must unregister all layouts that it registered.

    :param layout_id: The unique identifier for the layout.
    :return:
    """
    with lock:
        if layout_id not in layouts:
            raise ValueError(f"Layout id {layout_id} does not exist.")
        del layouts[layout_id]


# def set_layout(layout_id: str, layout: LayoutConfig) -> None:
#     """Set the layout configuration for this layout."""


def delete_layout(layout_id: str) -> None:
    """Destroy a layout and all config data for the layout."""
    raise NotImplementedError


def active_layout() -> str | None:
    """Get the unique id for the currently active layout."""
    return _active_layout


def activate_layout(layout_id: str) -> None:
    """Activate the layout.

    If the layout has a button, this just clicks the button, otherwise emulates the click.

    The layout must have been previously registered.

    :param layout_id: The unique identifier for the layout.
    :return:
    """
    with lock:
        layout_container = _get_layout_container(layout_id)
        button = layout_container.button()
        if button is not None:
            # If the layout has an associated button, click it.
            button.click()
        else:
            # If there is no associated button then manually enable it.
            get_main_window().toolbar.uncheck_layout_buttons()
            _setup_layout(layout_container.layout)


def create_layout_button(layout_id: str) -> ButtonProxy:
    """Create a button that will activate the specified layout.

    The layout must be registered before calling this.

    :param layout_id: The layout id for the layout that will be activated when clicked.
    """
    with lock:
        layout_container = _get_layout_container(layout_id)
        if layout_container.button() is not None:
            raise ValueError(f"A layout button for id {layout_id} already exists.")
        button = get_main_window().toolbar.add_layout_button()
        button.clicked.connect(lambda: _setup_layout(layout_container.layout))
        layout_container.button = ref(button)
        # TODO: set up the button
        #  Context menu:
        #   Reset to default layout
        #   Delete button

        return ButtonProxy(button)


def populate_widgets(widget_cls: type[TabWidget]) -> None:
    """Populate all missing widgets of this type.

    If a widget is created before its plugin is loaded it will be a missing widget.
    This function replaces all missing widgets with the real widget."""
    assert current_thread() is main_thread(), "This can only be called from the main thread."


def remove_widgets(widget_cls: type[TabWidget]) -> None:
    """Remove all widgets of this type and replace with a missing widget."""


def _setup_layout(layout: LayoutConfig) -> None:
    """Tear down the existing widgets and populate the new layout."""
    assert current_thread() is main_thread(), "This can only be called from the main thread."
    # Tear down existing layout

    # Set up new layout
    raise NotImplementedError


def _get_layout_config() -> LayoutConfig:
    """Get the current layout configuration."""
    raise NotImplementedError
